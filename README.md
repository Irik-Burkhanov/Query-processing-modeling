Имеется многоканальная СМО с ожиданием и неограниченной очередью. Для моделирования СМО обработки запросов необходимо задать параметры интенсивности прибытия запросов. Интенсивностью в данном случае будет количество запросов в секунду, прибывающих на сервера обработки.
разработаны алгоритмы: задания интенсивности поступления запросов в систему, генерации времени обработки и поступления запросов в систему, оценки эффективности системы обработки запросов, моделирования процесса обработки запросов.
Во время моделирования обработки запросов необходимо вычислять значения интенсивности в определенный момент времени.

Функция f(t, µ, σ) (возвращает значение функции плотности нормального распределения с математическим ожиданием µ и дисперсией σ2).
	st = 〖-(t-µ)〗^2/〖2σ〗^2
	Вернуть 1/√(2πσ_i ) e^st
Функция F(a,b, µ, σ) (возвращает вероятность поступления запроса в интервале времени [a;b]).
1.        Вернуть f((b- µ)/ σ, 0, 1) – f((a- µ)/ σ, 0,1)
Функция λ(time) (возвращает интенсивность поступления запросов (запрос/секунду) в системе в текущий момент времени, параметр time – текущее время в секундах, изменяется от 0 до T секунд).
	 F1 = F(0,T, µ1, σ1),
F2 = F(0,T, µ2, σ2),
F3 = F(0,T, µ3, σ3)
	f1 = k1 * f(time, µ1, σ1)/F1, 
f2 = k2 * f(time, µ2, σ2)/F2, 
f3 = k3 * f(time, µ3, σ3)/F3
	 Вернуть (f1 + f2 + f3) * α 

	Моделирование СМО обработки запросов

Исходные данные:
T – период моделирования;
m – количество серверов.
Переменные времени:
t – текущее время в часах.
Состояния системы:
SS = ((n, 0) (i1, j1), (i2, j2), …, (ik, jk), …, (im,jm)), 
где n – число запросов в системе, ik – число запросов в очереди у k устройства, jk – идентификационный номер запроса, который обслуживается устройством k, k = 1, …, m. 
Если в системе нет запросов, то SS = (0).
Если SS = ((1,0), (0,0), …, (1, i), …, 0), то имеется единственный запрос с номером i.
Количественные переменные:
NA - число запросов, прибывших к моменту времени t;
ND - число запросов, обслуженных к моменту времени t;
Ck - число запросов, обслуженных устройством k к моменту времени t, k = 1, …, m;
Xmin – минимальное время обслуживания запроса;
Xmax – максимальное время обслуживания запроса.
Список событий:
EL = (tA, t1, t2, …, tk, …, tm), где
t – время поступления следующего запроса;
tk – время завершения обслуживания текущего запроса на устройстве k; если нет запросов, которые нужно обслужить, то tk = ∞.
Выходные переменные:
Ai – время прибытия в систему запроса i, i = 1, …, NA;
Di – время ухода из системы запроса i, i = 1, …, NA;
ServiceTime(i) – время обслуживания устройством запроса i, i = 1, …, NA;
CashierBusyTime(k) – время, в течение которого устройство k занято, k = 1, …, m;
ST – Среднее время запросов в системе;
STQ – Средняя задержка запроса в очереди;
SQL – Средняя длина очереди;
Rk – Коэффициент занятости устройства k, k = 1, …, m;
R – Средний коэффициент занятости устройств. 

	Обобщенный алгоритм имитационного моделирования

Процедура генерация времени обслуживания с экспоненциальным законом распределения.
Время обслуживания запроса на сервере будет моделироваться по экспоненциальному закону распределения с параметром β (запрос/ms).
Функция GetServiceTime() {возвращает время обслуживания запроса сервером}.
1. Сгенерировать случайное число U (от 0 до 1).
2. X = -β  ln⁡U
3.1. Если (Xmin <= X <= Xmax)
3.2. Вернуть X.
Процедура генерации неоднородного Пуассоновского процесса.
Функция GetArrivalTime(time) {возвращает время первого прибытия запроса после времени time, параметр time – текущее время в часах}.
	t = time
	Сгенерировать случайное число U1 (от 0 до 1).
	t = t – 1/λ logU1
	Сгенерировать случайное число U2, независимое от U1
	Если U2 ≤ λ(t)/ λ, то вернуть t.
	Иначе: идти на шаг 2.
Функция GetAverageTime() {возвращает среднее время нахождения запроса в системе}.
1.	В цикле i от 1 до NA делать:
sum = sum + (Di - Ai)
конец цикла.
	Вернуть (sum/NA).
Функция GetAverageTimeInQueue() {возвращает среднее время задержки запроса в очереди}.
1.	В цикле i от 1 до NA делать:
sum = sum + (Di – (Ai + 〖ServiceTime〗_i))
конец цикла.
2.	Вернуть (sum/NA).
Функция GetCashBusyCoefficient(j) {возвращает коэффициент занятости устройства}.
	Вернуть CashierBusyTimej/T.
Функция GetAverageCashBusyCoefficient() {возвращает средний коэффициент занятости устройств}.
	В цикле j от 1 до m делать:
sum = sum + Rj
конец цикла.
	Вернуть (sum/m).
Алгоритм имитационного моделирования.
Функция SetInitialValues() {устанавливает в исходное состояние имитационную модель в момент времени, равный 0}.
	Присвоить t = NA = ND = C1 = C2 = …=Cm = 0
	Пока не конец массива SS: SS[i][j] = 0
	Пока не конец массива EL: EL[i] = ∞
Функция Modeling() {алгоритм имитационного моделирования}.
Шаг 1. SetInitialValues()
Шаг 2. Ta = GetArrivalTime(t)
Td = ∞
Шаг 3. EL[0] = Ta, EL[1] = EL[2] = … = EL[m]  = ∞
Шаг 4. Если (EL[0]  = min {EL[0],EL[1],…,EL[m]}, то //Если следующее событие – прибытие запроса в систему.
4.1.1. t = EL[0]
NextArrival = GetArrivalTime(t)
EL[0] = NextArrival
ANA = t 
NA = NA + 1
4.1.2. // Запрос начинает обработку на любом сервере.
SS[0][0] = SS[0][0] + 1
k = random(1, m).
SS[k][0] = SS[k][0] + 1
SS[k][1] = NA
Y = GetServiceTime()
EL[k] = t + Y
ServiceTime NA = Y
CashierBusyTime k = CashierBusyTime k +Y
TimeInQueue NA = 0
Если (S[k][0] >= 1), то //Если сервер занят запрос становится в очередь.
SS[k][0] = SS[k][0] + 1
4.1.3. Идти на шаг 4.
Если (EL[k] = min {EL[0],EL[1],…,EL[k]…,EL[m]}), то //Если
следующее событие – завершение обслуживания запроса на сервере k.
	t = EL[k]
Ck = Ck +1
Td = t
DND = t
ND = ND + 1
	Если(S[k][0] < 1), то //Если очередь пуста.
SS[0][0] = SS[0] – 1
SS[k][1] = 0
SS[k][0] = SS[k][0] – 1 
EL[k] = ∞
Иначе  //Запрос, который ждал в очереди дольше всех
начинает облуживание на сервере k.
NextRequest = max { SS[1][1],…,SS[k][1],…,SS[m][1]} + 1
SS[k][0] = SS[k][0] – 1
SS[k][1] = NextRequest
Y = GetServiceTime()
EL[k] = t + Y
ServiceTime NextRequest = Y
CashierBusyTime  k  = CashierBusyTime k +Y
TimeInQueue NextRequest = t - ANextRequest
	Идти на шаг 4.
Если (Td > T and SS[0][0] = 0 ), то //Если время ухода запроса из системы больше T и в системе не осталось запросов.
Идти на шаг 5.
Шаг 5.  ST = GetAverageTime()
STQ = GetAverageTimeInQueue()
5.1   в цикле j от 1 до m делать:
Rj = GetCashBusyCoefficient(j)
конец цикла.
R = GetAverageCashBusyCoefficient()
